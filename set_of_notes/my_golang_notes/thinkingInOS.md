# 操作系统的一些思考

## 目录

- #### <a href="#thread_safe">线程安全</a>

  - <a href="#what_is_thread_safe">1. 何为线程安全</a>
  - <a href="#how_to_ensure_thread_safe">2. 如何保障线程安全</a>

- #####  <a href="#what_is_thread_safe">何为线程安全</a>

  - <a href="#"></a>
  - <a href="#"></a>

- <a href="#"></a>

  - <a href="#"></a>
  - <a href="#"></a>
  - <a href="#"></a>

- <a href="#"></a>

  - <a href="#"></a>
  - <a href="#"></a>

- <a href="#"></a>

  - <a href="#"></a>
  - <a href="#"></a>

- <a href="#"></a>

- 



## <a name="thread_safe">线程安全</a>

### <a name="what_is_thread_safe">1. 何为线程安全</a>

【推荐阅读》》》】[线程安全](https://www.cnblogs.com/lixinjie/p/a-answer-about-thread-safety-in-a-interview.html)

“线程安全”不是指线程的安全，而是指内存的安全

在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以访问到该区域，这就是造成问题的潜在原因。

假设某个线程把数据处理到一半，觉得很累，就去休息了一会，回来准备接着处理，却发现数据已经被修改了，不是自己离开时的样子了。可能被其它线程修改了。

**所以线程安全指的是，在堆内存中的数据由于可以被任何线程访问到，在没有限制的情况下存在被意外修改的风险**。

即堆内存空间在没有保护机制的情况下，对多线程来说是不安全的地方，因为你放进去的数据，可能被别的线程“破坏”。

### <a name="how_to_ensure_thread_safe">2. 如何保障线程安全</a>

- 根据操作系统会为每个线程分配属于它自己的内存空间，通常称为栈内存，其它线程无权访问。将资源设置为局部变量，它们都会被分配在线程栈内存中；
- 将资源设置为常量
- 加锁
  - 悲观锁，持悲观态度，就是假设我的数据一定会被意外修改，那干脆直接加锁得了。
  - 乐观锁，持乐观态度，就是假设我的数据不会被意外修改，如果修改了，就放弃，比如利用`CAS（Compare And Swap）`。就是在并发很小的情况下，数据被意外修改的概率很低，但是又存在这种可能性，此时就用`CAS`。



### <a name=""></a>

### <a name=""></a>

### <a name=""></a>

### <a name=""></a>

### <a name=""></a>

### <a name=""></a>

### <a name=""></a>

### <a name=""></a>

### <a name=""></a>


































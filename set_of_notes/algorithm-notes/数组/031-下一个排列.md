## 题目

#### [31. 下一个排列(中等)](https://leetcode-cn.com/problems/next-permutation/)

实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须**原地**修改，只允许使用额外常数空间

```
输入：nums = [1,2,3]
输出：[1,3,2]
```

```go
输入：nums = [1,1,5]
输出：[1,5,1]
```



## 分析

【两次遍历】

- 第一遍：从后向前(倒数第二个数开始)找到第一个拐点, 这里拐点是指连续递增后遇到的第一个下降的数, 比如`[1 2 3 4 6 5]`里面`4`就是 拐点，像`(6 5 4 3 2 1)`这种就没有拐点, 因为已经是最大的排列了, 直接反转整个数组,；
- 第二遍：记下拐点的值`nums[i]`, 从`(i, len(nums)-1]`这个左开右闭区间(不包含拐点本身)找出第一个比拐点大的数,比如`[1 2 3 4 6 5]`里面的5，然后两者交换
- 最后,将拐点往后的区间反转



## 解答

```go
func nextPermutation(nums []int)  {
    N := len(nums)
    if N == 1 {
        return 
    }
    // 从后往前,找到第一个拐点(... 4 6 5)先递增后递减,4就是拐点
    i := N-2
    for i >= 0 && nums[i] >= nums[i+1] {
        i--
    }
    // 如果找到拐点(4 3 2 1这种连续递增同时也是最大的排列了就找不到拐点)
    if i >=0 {
        // 如果有拐点
        j := N-1
        // 从[i:N]这个区间里面找到第一个比拐点值nums[i]大的数
        for nums[i] >= nums[j] {
            j--
        }
        // 交换
        nums[i], nums[j] = nums[j], nums[i]
        // 将后序的数字都反转
        reverse(nums[i+1:])
    } else {
        // 如果没有拐点
        reverse(nums)
    }
}

func reverse(nums []int) {
    N := len(nums)
    for i := 0; i < N/2; i++ {
        nums[i], nums[N-1-i] = nums[N-1-i], nums[i]
    }
}
```

